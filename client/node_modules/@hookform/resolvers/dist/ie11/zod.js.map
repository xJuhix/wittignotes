{"version":3,"file":"zod.js","sources":["../../src/zod.ts"],"sourcesContent":["import {\n  appendErrors,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  transformToNestObject,\n} from 'react-hook-form';\nimport * as z from 'zod';\nimport { ParseParams } from 'zod/lib/src/parser';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  zodError: z.ZodError,\n  validateAllFieldCriteria: boolean,\n) => {\n  if (zodError.isEmpty) {\n    return {};\n  }\n\n  const errors = [...zodError.errors];\n  let previous: Record<string, any> = {};\n\n  for (const error of errors) {\n    const { path, message, code: type } = error;\n    const currentPath = convertArrayToPathName(path);\n\n    if ('unionErrors' in error) {\n      for (const subErrors of error.unionErrors.map((e) => e.errors)) {\n        errors.push(...subErrors);\n      }\n    }\n\n    previous = {\n      ...previous,\n      ...(path\n        ? previous[currentPath] && validateAllFieldCriteria\n          ? {\n              [currentPath]: appendErrors(\n                currentPath,\n                validateAllFieldCriteria,\n                previous,\n                type,\n                message,\n              ),\n            }\n          : {\n              [currentPath]: previous[currentPath] || {\n                message,\n                type,\n                ...(validateAllFieldCriteria\n                  ? {\n                      types: { [type]: message || true },\n                    }\n                  : {}),\n              },\n            }\n        : {}),\n    };\n  }\n\n  return previous;\n};\n\nexport const zodResolver = <T extends z.ZodSchema<any, any>>(\n  schema: T,\n  options?: ParseParams,\n): Resolver<z.infer<T>> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  const result = schema.safeParse(values, options);\n\n  if (result.success) {\n    return { values: result.data, errors: {} } as ResolverSuccess<z.infer<T>>;\n  }\n\n  return {\n    values: {},\n    errors: transformToNestObject(\n      parseErrorSchema(result.error, validateAllFieldCriteria),\n    ),\n  } as ResolverError<z.infer<T>>;\n};\n"],"names":["parseErrorSchema","zodError","validateAllFieldCriteria","isEmpty","errors","previous","errors_1","__values","error","path","message","type","currentPath","convertArrayToPathName","_f","unionErrors","map","e","subErrors","push","appendErrors","types","_e","schema","options","values","_","result","safeParse","success","data","transformToNestObject"],"mappings":"sMAWMA,EAAmB,SACvBC,EACAC,qBAEA,GAAID,EAASE,QACX,MAAO,GAGT,IAAMC,aAAaH,EAASG,QACxBC,EAAgC,OAEpC,IAAoB,IAAAC,EAAAC,WAAAH,iCAAQ,CAAvB,IAAMI,UACDC,EAA8BD,OAAxBE,EAAwBF,UAATG,EAASH,OAChCI,EAAcC,UAAuBJ,GAE3C,GAAI,gBAAiBD,MACnB,IAAwB,IAAAM,YAAAP,WAAAC,EAAMO,YAAYC,KAAI,SAACC,GAAM,OAAAA,EAAEb,0CAAS,CAA3D,IAAMc,UACTd,EAAOe,WAAPf,aAAec,sGAInBb,2BACKA,GACCI,EACAJ,EAASO,IAAgBV,UAEpBU,GAAcQ,eACbR,EACAV,EACAG,EACAM,EACAD,cAIDE,GAAcP,EAASO,gBACtBF,UACAC,QACIT,EACA,CACEmB,YAASC,EAACX,GAAOD,IAAW,MAE9B,OAGV,sGAIR,OAAOL,uBAGkB,SACzBkB,EACAC,GACyB,OAAA,SACzBC,EACAC,EACAxB,uBAAAA,gGAIA,OAFMyB,EAASJ,EAAOK,UAAUH,EAAQD,IAE7BK,WACF,CAAEJ,OAAQE,EAAOG,KAAM1B,OAAQ,QAGjC,CACLqB,OAAQ,GACRrB,OAAQ2B,wBACN/B,EAAiB2B,EAAOnB,MAAON"}