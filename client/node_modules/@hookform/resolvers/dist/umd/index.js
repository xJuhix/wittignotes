!function(e,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports,require("react-hook-form")):"function"==typeof define&&define.amd?define(["exports","react-hook-form"],s):s((e="undefined"!=typeof globalThis?globalThis:e||self).ReactHookFormResolvers={},e.ReactHookForm)}(this,(function(e,s){"use strict";class r extends TypeError{constructor(e,s){let r;const{message:t,...o}=e,{path:n}=e;super(0===n.length?t:"At path: "+n.join(".")+" -- "+t),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var t;return null!=(t=r)?t:r=[e,...s()]}}}function*t(e,s,r={}){const{path:o=[],branch:n=[e],coerce:a=!1}=r,c={path:o,branch:n};a&&(e=s.coercer(e,c));let i=!0;for(const r of s.validator(e,c))i=!1,yield[r,void 0];if(i)for(const r of s.refiner(e,c))i=!1,yield[r,void 0];for(let[r,l,f]of s.entries(e,c)){const s=t(l,f,{path:void 0===r?o:[...o,r],branch:void 0===r?n:[...n,l],coerce:a});for(const t of s)t[0]?(i=!1,yield[t[0],void 0]):a&&(l=t[1],void 0===r?e=l:e instanceof Map?e.set(r,l):e instanceof Set?e.add(l):"object"==typeof(u=e)&&null!=u&&(e[r]=l))}var u;i&&(yield[void 0,e])}function o(e,s,o={}){const n=t(e,s,o),a=function(e){const{done:s,value:r}=e.next();return s?void 0:r}(n);if(a[0]){return[new r(a[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]}return[void 0,a[1]]}var n=e=>e.reduce(((e,s,r)=>`${e}${"string"==typeof s?`${r>0?".":""}${s}`:`[${s}]`}`),"").toString();const a=(e,r)=>e.failures().reduce(((e,{path:t,message:o="",type:a})=>{const c=n(t);return Object.assign(Object.assign({},e),t?e[c]&&r?{[c]:s.appendErrors(c,r,e,a||"",o)}:{[c]:e[c]||Object.assign({message:o,type:a},r?{types:{[a||""]:o||!0}}:{})}:{})}),{}),c=(e,r)=>Array.isArray(e.details)?e.details.reduce(((e,{path:t,message:o="",type:a})=>{const c=n(t);return Object.assign(Object.assign({},e),t?e[c]&&r?{[c]:s.appendErrors(c,r,e,a,o)}:{[c]:e[c]||Object.assign({message:o,type:a},r?{types:{[a]:o||!0}}:{})}:{})}),{}):[],i=(e,r)=>{if(e.isEmpty)return{};const t=[...e.errors];let o={};for(const e of t){const{path:a,message:c,code:i}=e,u=n(a);if("unionErrors"in e)for(const s of e.unionErrors.map((e=>e.errors)))t.push(...s);o=Object.assign(Object.assign({},o),a?o[u]&&r?{[u]:s.appendErrors(u,r,o,i,c)}:{[u]:o[u]||Object.assign({message:c,type:i},r?{types:{[i]:c||!0}}:{})}:{})}return o},u=(e,s)=>Object.entries(e).reduce(((e,[r,t])=>Object.assign(Object.assign({},e),{[r]:Object.assign({type:"",message:t[0]},s?{types:t.reduce(((e,s,r)=>Object.assign(Object.assign({},e),{[r]:s})),{})}:{})})),{});e.joiResolver=(e,r={abortEarly:!1})=>async(t,o,n=!1)=>{try{return{values:await e.validateAsync(t,Object.assign(Object.assign({},r),{context:o})),errors:{}}}catch(e){return{values:{},errors:s.transformToNestObject(c(e,n))}}},e.superstructResolver=(e,r)=>(t,n,c=!1)=>{const[i,u]=o(t,e,r);return null!=i?{values:{},errors:s.transformToNestObject(a(i,c))}:{values:u,errors:{}}},e.vestResolver=(e,r={},t=!1)=>async r=>{const o=(n=e,(...e)=>new Promise((s=>n(...e).done(s))));var n;const a=await o(r),c=a.getErrors();return a.hasErrors()?{values:{},errors:s.transformToNestObject(u(c,t))}:{values:r,errors:{}}},e.yupResolver=(e,r={abortEarly:!1})=>async(t,o,n=!1)=>{try{return r.context&&process.env.NODE_ENV,{values:await e.validate(t,Object.assign(Object.assign({},r),{context:o})),errors:{}}}catch(e){const r=((e,s)=>Array.isArray(e.inner)&&e.inner.length?e.inner.reduce(((e,{path:r,message:t,type:o})=>{const n=e[r]&&e[r].types||{},a=r||o;return Object.assign(Object.assign({},e),a?{[a]:Object.assign(Object.assign({},e[a]||{message:t,type:o}),s?{types:Object.assign(Object.assign({},n),{[o]:n[o]?[...[].concat(n[o]),t]:t})}:{})}:{})}),{}):{[e.path]:{message:e.message,type:e.type}})(e,n);return{values:{},errors:s.transformToNestObject(r)}}},e.zodResolver=(e,r)=>async(t,o,n=!1)=>{const a=e.safeParse(t,r);return a.success?{values:a.data,errors:{}}:{values:{},errors:s.transformToNestObject(i(a.error,n))}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.js.map
